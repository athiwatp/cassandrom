var Document = require('./document');
var Query = require('./query');
var parallel = require('async/parallel');

var utils = require('./utils');
var error = require('./error');
var Promise = require('./promise');
var EventEmitter = require('events').EventEmitter;

//var when = require('when');

function Model(doc, fields) {
  //this.connections = [];
  //this.plugins = [];
  //this.models = {};
  //this.modelSchemas = {};
  Document.call(this, doc, fields);


/*
  this.options = {

  };


  this.isNew = true;
  var obj = this.$__normalize(doc);

  this._doc = this.$__buildDoc(obj, fields);

  if (doc) {
    this.set(obj, undefined, true);
  }
  */
}

// Model.prototype.constructor = Model;


Model.prototype.__proto__ = Document.prototype;

// Model.prototype.schema;

Model.prototype.modelName;

Model.prototype.db;

Model.prototype.collection;

Model.prototype.baseModelName;

for (var i in EventEmitter.prototype) {
  Model[i] = EventEmitter.prototype[i];
}

Model.init = function init () {
  if ((this.schema.options.autoIndex) ||
      (this.schema.options.autoIndex === null && this.db.config.autoIndex)) {
    this.ensureIndexes({ __noPromise: true, _automatic: true });
  }

  this.schema.emit('init', this);
};

Model.ensureIndexes = function ensureIndexes(options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (options && options.__noPromise) {
    _ensureIndexes(this, options, callback);
    return;
  }
/*
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
*/
  var _this = this;
  return new Promise(function(resolve, reject) {
    _ensureIndexes(_this, options || {}, function(error) {
      if (error) {
        callback && callback(error);
        reject(error);
      }
      callback && callback();
      resolve();
    });
  });
};

function _ensureIndexes(model, options, callback) {
  var indexes = model.schema.indexes();
  if (!indexes.length) {
    setImmediate(function() {
      callback && callback();
    });
    return;
  }
  // TODO index
  console.log('TODO index support');
}
/*
Model.prototype.model = function model(name) {
  return this.db.model(name);
};
*/

// Model.prototype.getValue = function (path) {
//   console.log(" ##### " + JSON.stringify( this._doc ) + ' path ' + path);
//   return this._doc[path];
//   // return utils.getValue(path, this._doc);
// }

Model.prototype.save = function save (options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = undefined;
  }

  if (!options) {
    options = {};
  }
  return this.$__save(options, fn);
};

Model.prototype.$__save = function(options, callback) {
  var _this = this;

  _this.$__handleSave(options, function(error, result) {
    if (error) {
      return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
        callback(error);
      });
    }

    _this.$__reset();
    _this.$__storeShard();

    var numAffected = 0;
    if (result) {
      if (Array.isArray(result)) {
        numAffected = result.length;
      } else if (result.result && result.result.n !== undefined) {
        numAffected = result.result.n;
      } else if (result.result && result.result.nModified !== undefined) {
        numAffected = result.result.nModified;
      } else {
        numAffected = result;
      }
    }

    // was this an update that required a version bump?
    if (_this.$__.version && !_this.$__.inserting) {
      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);
      _this.$__.version = undefined;

      if (numAffected <= 0) {
        // the update failed. pass an error back
        var err = new VersionError(_this);
        return callback(err);
      }

      // increment version if was successful
      if (doIncrement) {
        var key = _this.schema.options.versionKey;
        var version = _this.getValue(key) | 0;
        _this.setValue(key, version + 1);
      }
    }

    _this.emit('save', _this, numAffected);
    callback(null, _this, numAffected);
  });
};

Model.prototype.$__handleSave = function(options, callback) {
  var _this = this;
  if (!options.safe && this.schema.options.safe) {
    options.safe = this.schema.options.safe;
  }
  if (typeof options.safe === 'boolean') {
    options.safe = null;
  }

  if (this.isNew) {
    // send entire doc
    var toObjectOptions = {};

    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;
    toObjectOptions.depopulate = 1;
    toObjectOptions._skipDepopulateTopLevel = true;
    toObjectOptions.transform = false;

    var obj = this.toObject(toObjectOptions);
/*
    if (!utils.object.hasOwnProperty(obj || {}, '_id')) {
      // documents must have an _id else mongoose won't know
      // what to update later if more changes are made. the user
      // wouldn't know what _id was generated by mongodb either
      // nor would the ObjectId generated my mongodb necessarily
      // match the schema definition.
      setTimeout(function() {
        callback(new Error('document must have an _id before saving'));
      }, 0);
      return;
    }

    this.$__version(true, obj);
*/
    var insert = this.schema.insert(this.modelName, this, options), self = this;
    if(insert.error) {
      self.isNew = true;
      self.emit('isNew', true);

      callback(insert.error);
    } else {
      this.base.execute(insert.query, insert.params, {prepare: true}, function(error, status) {
        if(error) {
          self.isNew = true;
          self.emit('isNew', true);

          callback(error);
        } else {
          self.isNew = false;
          callback(null, self);
        }
      });
    }

/* TODO
    this.collection.insert(obj, options.safe, function(err, ret) {
      if (err) {
        _this.isNew = true;
        _this.emit('isNew', true);

        callback(err);
        return;
      }

      callback(null, ret);
    });
*/
    this.$__reset();
    this.isNew = false;
    this.emit('isNew', false);
    // Make it possible to retry the insert
    this.$__.inserting = true;
  } else {
    // Make sure we don't treat it as a new object on error,
    // since it already exists
    this.$__.inserting = false;

    var delta = this.$__delta();

    if (delta) {
      if (delta instanceof Error) {
        callback(delta);
        return;
      }

      var where = this.$__where(delta[0]);

      if (where instanceof Error) {
        callback(where);
        return;
      }

      var update = this.schema.update(this.modelName, this, where, delta[1], options), self = this;
      if(update.error) {
        callback(update.error);
      } else {
        this.base.execute(update.query, update.params, {prepare: true}, function(error, status) {
          if(error) {
            callback(error);
          } else {
            callback(null, self);
          }
        });
      }

      // this.collection.update(where, delta[1], options.safe, function(err, ret) {
      //   if (err) {
      //     callback(err);
      //     return;
      //   }
      //   callback(null, ret);
      // });
    } else {
      this.$__reset();
      callback();
      return;
    }

    this.emit('isNew', false);
  }
};


Model.prototype.$__try = function (fn, scope) {
  var res;
  try {
    fn.call(scope);
    res = true;
  } catch (e) {
    this.$__error(e);
    res = false;
  }
  return res;
};


Model.prototype.$__error = function(error) {
  console.error("[cassandrom] Error: " + error);
};
// Model.prototype.$__shouldModify = function (
//     pathToMark, path, constructing, parts, schema, val, priorVal) {

//   if (this.isNew) return true;

//   if (undefined === val && !this.isSelected(path)) {
//     // when a path is not selected in a query, its initial
//     // value will be undefined.
//     return true;
//   }

//   if (undefined === val && path in this.$__.activePaths.states.default) {
//     // we're just unsetting the default value which was never saved
//     return false;
//   }

//   if (!deepEqual(val, priorVal || this.get(path))) {
//     return true;
//   }

//   if (!constructing &&
//       null != val &&
//       path in this.$__.activePaths.states.default &&
//       deepEqual(val, schema.getDefault(this, constructing))) {
//     // a path with a default was $unset on the server
//     // and the user is setting it to the same value again
//     return true;
//   }
//   return false;
// }
/*
Model.prototype.$__set = function (
    pathToMark, path, constructing, parts, schema, val, priorVal) {

  // var shouldModify = this.$__shouldModify.apply(this, arguments);
  var _this = this;

  // if (shouldModify) {
  //   this.markModified(pathToMark, val);
  // }

  var obj = this._doc
    , i = 0
    , l = parts.length

  for (; i < l; i++) {
    var next = i + 1
      , last = next === l;

    if (last) {
      obj[parts[i]] = val;
    } else {
      if (obj[parts[i]] && 'Object' === obj[parts[i]].constructor.name) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && 'EmbeddedDocument' === obj[parts[i]].constructor.name) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj = obj[parts[i]] = {};
      }
    }
  }
}
*/

Model.create = function create(doc, callback) {
  var args;
  var cb;

  if (Array.isArray(doc)) {
    args = doc;
    cb = callback;
  } else {
    var last = arguments[arguments.length - 1];
    if (typeof last === 'function') {
      cb = last;
      args = utils.args(arguments, 0, arguments.length - 1);
    } else {
      args = utils.args(arguments);
    }
  }

  var _this = this;
  // if (cb) {
  //   cb = this.$wrapCallback(cb);
  // }

  var promise = new Promise(function(resolve, reject) {
    if (args.length === 0) {
      setImmediate(function() {
        cb && cb(null);
        resolve(null);
      });
      return;
    }

    var toExecute = [];
    args.forEach(function(doc) {
      toExecute.push(function(callback) {
        var toSave = doc instanceof _this ? doc : new _this(doc);
        var callbackWrapper = function(error, doc) {
          if (error) {
            return callback(error);
          }
          callback(null, doc);
        };

        // Hack to avoid getting a promise because of
        // $__registerHooksFromSchema
        if (toSave.$__original_save) {
          toSave.$__original_save({ __noPromise: true }, callbackWrapper);
        } else {
          toSave.save({ __noPromise: true }, callbackWrapper);
        }
      });
    });

    parallel(toExecute, function(error, savedDocs) {
      if (error) {
        if (cb) {
          cb(error);
        } else {
          reject(error);
        }
        return;
      }

      if (doc instanceof Array) {
        resolve(savedDocs);
        cb && cb.call(_this, null, savedDocs);
      } else {
        resolve.apply(promise, savedDocs);
        if (cb) {
          savedDocs.unshift(null);
          cb.apply(_this, savedDocs);
        }
      }
    });
  });

  return promise;
};

/*

Model.__escape = function(val, timeZone) {
  if (val === undefined || val === null) {
    return 'NULL';
  }

  switch (typeof val) {
    case 'boolean': return (val) ? 'true' : 'false';
    case 'number': return val+'';
  }

  if (val instanceof Date) {
    val = Model.__dateToString(val, timeZone || 'local');
  }

  val = val.replace(/[\0\n\r\b\t\\\'\"\x1a]/g, function(s) {
    switch(s) {
      case "\0": return "\\0";
      case "\n": return "\\n";
      case "\r": return "\\r";
      case "\b": return "\\b";
      case "\t": return "\\t";
      case "\x1a": return "\\Z";
      default: return "\\"+s;
    }
  });
  return "'"+val+"'";
};


Model.__dateToString = function(date, timeZone) {
  var dt = new Date(date);

  if (timeZone != 'local') {
    var tz = convertTimezone(timeZone);

    dt.setTime(dt.getTime() + (dt.getTimezoneOffset() * 60000));
    if (tz !== false) {
      dt.setTime(dt.getTime() + (tz * 60000));
    }
  }

  var year   = dt.getFullYear();
  var month  = zeroPad(dt.getMonth() + 1, 2);
  var day    = zeroPad(dt.getDate(), 2);
  var hour   = zeroPad(dt.getHours(), 2);
  var minute = zeroPad(dt.getMinutes(), 2);
  var second = zeroPad(dt.getSeconds(), 2);
  var millisecond = zeroPad(dt.getMilliseconds(), 3);

  return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second + '.' + millisecond;
};

Model.__escapeQuery = function(obj) {
  var values = "";
  for(var p in obj) {
    if(values.length > 0) {
      values += ",";
    }
    values += p + " = " + Model.__escape(obj[p]);
  }
  return values;
};
*/
// Model.findById = function findById (id, fields, options, callback) {
//   return this.findOne({ row: id }, fields, options, callback);
// };

Model.count = function count(conditions, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
  }

  var query = new Query({}, this, {});
  return query.count(conditions, callback);
};

Model.find = function find (conditions, projection, options, callback) {
  if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
    projection = null;
    options = null;
  } else if (typeof projection === 'function') {
    callback = projection;
    projection = null;
    options = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  var query = new Query({}, this, {});
  query.select(projection);
  query.setOptions(options);
  return query.find(conditions, callback);
/*
  var self = this;
  var _results;
  var promise = new Promise(function(resolve, reject) {
    var select = self.schema.select(self.modelName, conditions, fields, limit);
    if(!select) {
      resolve();
      return;
    }
    self.base.execute(select.query, select.params, {prepare: true}, function(error, result) {
      if (error) {
        console.log('[cassandrom] Query error: ' + error);
        reject(error);
        return;
      }
      self.$__parseData(self, fields, result, limit, function(error, data) {
        _results = [error, data];
        if(error) {
          console.log('[cassandrom] Query error: ' + error);
          reject(error);
        } else {
          resolve(data);
        }
      });
    });
  });

  if (callback) {
    promise.then(
      function() {
        callback.apply(null, _results);
      },
      function(error) {
        callback(error);
      }).
      catch(function(error) {
        setImmediate(function() {
          console.log('[cassandrom] Error ' + self.model + ', ' + error);
          self.model.emit('error', error);
        });
      });
  }

promise.exec = function(op, callback) {
  if (typeof op === 'function') {
    callback = op;
  }

  this.then(
    function() {
      callback.apply(null, _results);
    },
    function(error) {
      callback(error);
    }).
    catch(function(error) {
      setImmediate(function() {
        self.model.emit('error', error);
      });
  });
};

promise.populate = function(name) {

};

promise.count = function(conditions, callback) {
  return self.count(conditions, callback);
};

promise.limit = function(ll) {
  limit = ll;
};

promise.skip = function(skip) {

};

promise.sort = function(sort) {

};

  return promise;
  */
}

Model.findOne = function findOne (conditions, projection, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = null;
  } else if (typeof projection === 'function') {
    callback = projection;
    projection = null;
    options = null;
  } else if (typeof conditions === 'function') {
    callback = conditions;
    conditions = {};
    projection = null;
    options = null;
  }

  var query = new Query({}, this, {});
  query.select(projection);
  query.setOptions(options);
  return query.findOne(conditions, callback);
};

Model.findById = function findById(id, projection, options, callback) {
  if (typeof id === 'undefined') {
    id = null;
  }

  return this.findOne({_id: id}, projection, options, callback);
};

Model.$__result = function(callback, limit) {
  var self = this;
  return function(error, result) {

    if(error) {
      console.log('[cassandrom] Query error: ' + error);
      callback(error);
    } else {
      self.$__parseData(self, undefined, result, limit, callback);
    }
  };
};
/*
function completeOne(model, doc, res, fields, self, pop, callback) {
  var opts = pop ?
  {populated: pop}
      : undefined;

console.log('completeOne model ' + model._);
  var casted = helpers.createModel(model, doc, fields);
  console.log('completeOne ' + casted._);
  casted.init(doc, opts, function(err) {
    if (err) {
      return callback(err);
    }
    console.log('completeOne  init ' + casted._);
    if (res) {
      return callback(null, casted, res);
    }
    callback(null, casted);
  });
}
*/


Model.$__parseData = function(model, fields, data, limit, callback) {
  var list = [];
  if(data.rows && data.rows.length > 0) {
    var i = 0, obj, p, size = (limit  && limit > 0) ? limit : data.rows.length;

    // var len = count;
    // function init(err) {
    //   if (err) return callback(err);
    //   --count || callback(null, arr);
    // }
    var count = size;
    for(; i < size; i++) {
      // undefined, fields, true
      list.push( obj );
      obj = new model( undefined, fields, true); //data.rows[i] );
      obj.init(data.rows[i], undefined, function(err) {
        --count;
        if (err) {
          return callback(err);
        }
        if(count === 0) {
          callback(null, limit === 1 ? obj : list);
        }
      });

  // new model(undefined, fields, true);


    }
  } else {
    callback(null, limit === 1 ? null : []);
  }
  // if(list.length > 0) {
  //   if(one) {
  //     return list[0];
  //   } else {
  //     return list;
  //   }
  // }
  // return null;
};

Model.prototype.$__setSchema = function (schema) {
  compileObject(schema.tree, this);
  this.schema = schema;
}

Model.prototype.$__setModelName = function (modelName) {
  this.modelName = modelName;
}

Model.compile = function compile (name, schema, collectionName, base) {
  // generate new class
  function model (doc, fields, skipId) {
    if (!(this instanceof model)) {
      return new model(doc, fields, skipId);
    }
    Model.call(this, doc, fields, skipId);
  };

  model.hooks = schema.s.hooks.clone();
  model.base = model.prototype.base = base;
  model.modelName = name;

  if (!(model.prototype instanceof Model)) {
    model.__proto__ = Model;
    model.prototype.__proto__ = Model.prototype;
  }

  model.model = Model.prototype.model;
  // model.db = model.prototype.db = connection;

  model.prototype.$__setSchema(schema);

  model.prototype.$__setModelName(name);
  // model.modelName = model.prototype.modelName;

  // apply methods and statics
  applyMethods(model, schema);
  applyStatics(model, schema);

  model.schema = model.prototype.schema;
  model.collection = model.prototype.collection;

  model.options = model.prototype.options;

  return model;
};

function compileObject (tree, proto, prefix) {
  var keys = Object.keys(tree)
    , i = keys.length
    , limb
    , key;

  while (i--) {
    key = keys[i];
    limb = tree[key];

    define(key
        , (('Object' === limb.constructor.name
               && Object.keys(limb).length)
               && (!limb.type || limb.type.type)
               ? limb
               : null)
        , proto
        , prefix
        , keys);
  }
};

function define (prop, subprops, prototype, prefix, keys) {
  var prefix = prefix || ''
    , path = (prefix ? prefix + '.' : '') + prop;

  if (subprops) {

    Object.defineProperty(prototype, prop, {
        enumerable: true
      , configurable: true
      , get: function () {
          if (!this.$__.getters)
            this.$__.getters = {};

          if (!this.$__.getters[path]) {
            var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));

            // save scope for nested getters/setters
            if (!prefix) nested.$__.scope = this;

            // shadow inherited getters from sub-objects so
            // thing.nested.nested.nested... doesn't occur (gh-366)
            var i = 0
              , len = keys.length;

            for (; i < len; ++i) {
              // over-write the parents getter without triggering it
              Object.defineProperty(nested, keys[i], {
                  enumerable: false   // It doesn't show up.
                , writable: true      // We can set it later.
                , configurable: true  // We can Object.defineProperty again.
                , value: undefined    // It shadows its parent.
              });
            }

            nested.toObject = function () {
              return this.get(path);
            };

            compileObject(subprops, nested, path);
            this.$__.getters[path] = nested;
          }

          return this.$__.getters[path];
        }
      , set: function (v) {
          if (v instanceof Document) v = v.toObject();
          return (this.$__.scope || this).set(path, v);
        }
    });

  } else {
    Object.defineProperty(prototype, prop, {
        enumerable: true
      , configurable: true
      , get: function ( ) {
          return this.get.call(this, path);
        }
      , set: function (v) {
        return this.set.call(this, path, v);
      }
    });
  }
};


Model.prototype.toObject = function (options) {
  if (options && options.depopulate /* && this.$__.wasPopulated */ ) {
    // populated paths that we set to a document
    return utils.clone(this._id, options);
  }

  // When internally saving this document we always pass options,
  // bypassing the custom schema options.
  var optionsParameter = options;
  if (!(options && 'Object' == options.constructor.name) ||
      (options && options._useSchemaOptions)) {
    options = this.schema.options.toObject
      ? utils.clone(this.schema.options.toObject)
      : {};
  }

  ;('minimize' in options) || (options.minimize = this.schema.options.minimize);
  if (!optionsParameter) {
    options._useSchemaOptions = true;
  }

  var ret = utils.clone(this._doc, options);

  if (options.virtuals || options.getters && false !== options.virtuals) {
    applyGetters(this, ret, 'virtuals', options);
  }

  if (options.getters) {
    applyGetters(this, ret, 'paths', options);
    // applyGetters for paths will add nested empty objects;
    // if minimize is set, we need to remove them.
    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (true === options.transform ||
      (this.schema.options.toObject && options.transform)) {
    var opts = options.json
      ? this.schema.options.toJSON
      : this.schema.options.toObject;
    if (opts) {
      options.transform = opts.transform;
    }
  }

  if ('function' == typeof options.transform) {
    var xformed = options.transform(this, ret, options);
    if ('undefined' != typeof xformed) ret = xformed;
  }

  return ret;
};

Model.prototype.toJSON = function (options) {
  // check for object type since an array of documents
  // being stringified passes array indexes instead
  // of options objects. JSON.stringify([doc, doc])
  // The second check here is to make sure that populated documents (or
  // subdocuments) use their own options for `.toJSON()` instead of their
  // parent's
  if (!(options && 'Object' == options.constructor.name)
      || ((!options || options.json) && this.schema.options.toJSON)) {
    options = this.schema.options.toJSON
      ? utils.clone(this.schema.options.toJSON)
      : {};
  }
  options.json = true;

  return this.toObject(options);
};


function getOwnPropertyDescriptors(object) {
  var result = {};

  Object.getOwnPropertyNames(object).forEach(function(key) {
    result[key] = Object.getOwnPropertyDescriptor(object, key);
    result[key].enumerable = true;
  });

  return result;
}

function minimize (obj) {
  var keys = Object.keys(obj)
    , i = keys.length
    , hasKeys
    , key
    , val

  while (i--) {
    key = keys[i];
    val = obj[key];

    if (utils.isObject(val)) {
      obj[key] = minimize(val);
    }

    if (undefined === obj[key]) {
      delete obj[key];
      continue;
    }

    hasKeys = true;
  }

  return hasKeys
    ? obj
    : undefined;
}


function applyGetters (self, json, type, options) {
  var schema = self.schema
    , paths = Object.keys(schema[type])
    , i = paths.length
    , path

  while (i--) {
    path = paths[i];

    var parts = path.split('.')
      , plen = parts.length
      , last = plen - 1
      , branch = json
      , part

    for (var ii = 0; ii < plen; ++ii) {
      part = parts[ii];
      if (ii === last) {
        branch[part] = utils.clone(self.get(path), options);
      } else {
        branch = branch[part] || (branch[part] = {});
      }
    }
  }

  return json;
}


/*!
 * Register methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
var applyMethods = function(model, schema) {
  function apply(method, schema) {
    Object.defineProperty(model.prototype, method, {
      get: function() {
        var h = {};
        for (var k in schema.methods[method]) {
          h[k] = schema.methods[method][k].bind(this);
        }
        return h;
      },
      configurable: true
    });
  }
  for (var method in schema.methods) {
    if (typeof schema.methods[method] === 'function') {
      model.prototype[method] = schema.methods[method];
    } else {
      apply(method, schema);
    }
  }
};

/*!
 * Register statics for this model
 * @param {Model} model
 * @param {Schema} schema
 */
var applyStatics = function(model, schema) {
  for (var i in schema.statics) {
    model[i] = schema.statics[i];
  }
};

module.exports = exports = Model;